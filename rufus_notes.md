# Notes from Pete

## 1
Source : https://github.com/pbatard/rufus/issues/679

Yup. My most conservative estimate put the effort at a minimum of 6 months, full time work, to do a port that I would consider barely worthy of release.

Oh, and this question gets asked over (#550) and over (#509) and over (#520) and over (#515) (and I could go on!). So, next time, please don't be afraid to use search before asking for something that, in all likelihood, you're probably not the first person to ask.

Besides, it's not like there isn't a dedicated FAQ entry for this very question.

Now, if you really want to know what might be so hard, well...

  - First of all, there's the whole UI to redesign from scratch, since it's intimately tied to Windows. Even if using a framework (but then bye bye small size app), you can count at least 2 months of work, especially as I'm already planning on one month of work just to redesign the UI for Rufus 3.0 on Windows only (to better handle positioning, Windows 10 recommended UI elements, high DPI and stuff). [NB: The redesign for Rufus 3.0 actually took 4 months, so, yeah, I hope you'll excuse me for not being too keen on to find out by how much I am off, wrt to my "porting to Linux" estimate...]
  - Then there's the whole matter that formatting is not actually done by Rufus, but by asking Windows nicely, to do that for us through one of the numerous native DLLs we have at our disposal. Which works great when you have an OS that has native NTFS support. But suddenly, if you're on Linux, or even worse, OS X (because if you're gonna start porting to Linux, you might as well open the road for OS X), you need to ensure that people have the right dependencies and stuff. Still, that's not exactly the worst...
  - The worst is, if you want Windows To Go, or VHD dump (which Rufus happily does), then you're probably going to have to write your own library for it, pretty much from sratch. Yeah, there exist wimlib, but 1) It's a pain to use if you want to remove stuff that you don't need and 2) it doesn't handle the writing of the BCD, without which you're not gonna boot anything To Go anyway. And I'm not even going to talk about the need to have an ISO mounted and accessible before you can do anything to set up To Go (which, to be fair, might be one of the few things that might be simpler to implement on Linux compared to Windows).
  - Oh, and God forbid Microsoft do what they usually do, and change their API in a new version of Windows (which they actually did in Windows 10), because then, instead of simply going with the flow, you're going to have to (re)implement whatever it is they did in Linux/OS X just to be on par in terms of features.
  - Finally, if you know a good implementation of ReFS for Linux (since Rufus can happily format a drive using ReFS on Windows), I'm all hears. Otherwise, yeah, whatever port of Rufus is being carried out will have to compromise A LOT in terms of features, and then, even as I might have spent more than half a year working on a Linux port, I'll still have to answer a new github request every other week on how difficult it could actually be to allow the Linux version of Rufus to format a drive to ReFS.

I realize that I may sound flippant, but I really wish that people would realize that, yes, there exist a very good reason a Linux or OS X port is not happening anytime soon (and will most likely never happen). Hope that answers your question.
 

## 2
Source: https://github.com/pbatard/rufus/issues/679

I'm afraid I'll have to say: the documentation is already there - it's the Rufus source!
I feel like I'd do a disservice to whoever wants to understand Rufus if I tried to write documentation, because I would most definitely miss critical data, which users would complain about. Heck that actually already happened (The "and adds a line, which github.com/pbatard/rufus/wiki/Targets-Supported does not mention, so thank..." part), so, yeah, there's a reason why most developers won't write doc. It's because someone who wants to truly understand what an Open Source application does is always better off reading the code itself.

As to your other points: Rufus is designed around having an UI. I actually have a >3 year old request around adding commandline support, which I'm deferring because from implementing part of it, I've seen how much of a massive pain it was to turn a UI operation into a commandline one.

With regards to NTFS, there is no guarantee that Linux will have NTFS support, so it'll need to be detected (which is no big deal, but then, what do you do if it isn't present). And NTFS is only one of the many filesystems Rufus supports. I very much doubt that many Linux systems come with exFAT. And what about UDF formatting? Those come native on Windows. And I already mentioned ReFS. So yeah, Linux users will have to contend with 2 file systems (NTFS and FAT32) instead of 5. Or let's talk about the quirks needed for make Windows 7 EFI bootable (need to extract the EFI boot file from a .wim). If we decide to go without .wim Support, then suddenly people can't install Windows 7 in EFI mode. Also, you can forget about MS-DOS, since the files are non redistributable and come from a Windows DLL. Granted, people should be okay with FreeDOS (and Windows 10 did away with MS-DOS anyway), but now the app is starting to look more and more and crippled... and, as I mention in the FAQ, if you are going to remove that many features, your app's going turn out not that different from what you can easily get by installing ms-sys (did you know the newly released ms-sys can install ALL of the boot records that Rufus can handle?) plus Grub or Syslinux. So the question quickly becomes, what's the point of porting Rufus if, in the end, what you're going to be left with is stuff you can already accomplish with a handful of native Linux commandline tools today.

## 3
Source: https://github.com/pbatard/rufus/issues/1450

You are assuming wrong. If it was just the UI where the bulk of the effort was required, I'd have produced a Linux port a long time ago.

It's the whole formatting for NTFS, FAT, ReFS, UDF + device detection + partitioning + WIM support that is the issue. We are tightly integrated with the Windows formatting, partitioning and WIM libraries because they are available and avoid having to reinvent the wheel (or find a squared wheel that we need to chip away to make round for our purpose).

Granted, you're going to tell me that (besides ReFS), file system support "should" be easy: Just hook into or invoke mkfs and mount behind the scenes. And likewise, just need to add wimlib for WIM support... But then you get all the corner cases such as:

  - Can't invoke bcdboot.exe on Linux to finalize Windows To Go. — Oh well, you're gonna tell me, who needs Windows To Go anyway...
  - No PowerShell to run the Windows ISO download script — Bah, who cares about conveniently downloading Windows ISOs from Rufus... It's not like Linux users would expect the same functionality as the Windows version anyway (or, one can just convert the FIDO PowerShell script to a shell script, coz it shouldn't take that long)
  - No convenient FormatEx invocation for FAT/NTFS/exFAT/UDF/ReFS support in a single call — No big deal, just rewrite the whole thing to hook into mkfs and mount. And besides changing the whole formatting invocation, properly detecting (and validating) whether a system does have exFAT or NTFS formatting support, and reporting that to the user if it doesn't, is definitely not something that's going to take more than a couple of days at best...
  - Detecting when a drive is plugged? — Easy: simply hook into the Linux calls that do the equivalent work from Window, and make sure to hook that to the UI refresh... If you need more than a week to do that, you must be doing it wrong!
  - And so on, and so forth... I hope you see where I'm going with this, coz I'm barely scratching the surface here...

Even if it takes 1 month to get a super basic version of Rufus, as opposed to the 4 months minimum that I estimate are needed (and that estimate assumes full days of work, of ~8-10 hours/day), that's one month that I simply can't justify myself allocating when I have tons of other things that I know are going benefit people a lot more than a half-assed version of Rufus hastily put together. I'm actually quite happy to see that the woeusb folks are trying to take over the task of creating Windows drives on Linux because between what most people hope a port of Rufus would be like (something that would be very close to the Windows version in terms of features) and the reality, there would be such a big gap that I'd expect a huge backlash from simply calling that application "Rufus".

    I think you might be overestimating the workload it would take to write a linux build.

I'm not. I've created Windows + Linux + Mac UI applications in the past. Even when using common libraries (e.g. games using OpenGL), you are going to run into all the corner cases (Want sound on Linux? Sure, just use ALSA. After all, there's no good reason why many people claim that using ALSA is akin to diving into the depth of hell. None at all... And if you're going to tell me I'd have been better off using Godot or Unity or whatever, I'll counter that I would have required a whole costly rewrite of the existing code, and that, for all its flaws, going for ALSA was still the less demanding option).

Oh, and for the record, reworking the Rufus UI between 2.18 and 3.0 is something that literally took about 3 months of full time work. And that was a "simple" UI rework that didn't even require switching libraries and stuff or abstracting things around (and no, that was not just done for eye-candy. It was something that was very needed to improve the pain points from UI usage, and that I had to delay for about 4 years before I could allocate the required amount of time... which I found I had seriously underestimated). So, yeah, I don't believe that my estimate of the work needed for a Linux port is an exaggeration, because there really is a lot more happening behind the scenes in Rufus than meets the eyes.

Besides, reuse of a library, even mature ones, is never ever trouble free. For the record, it took me about 2-3 months of extensive work to be able to reuse libcdio in Rufus, and more recently it also took about 2 months to integrate ext2fs for ext2/ext3 formatting... and I still have major bugs to fix... which I've actually spent the last 3-4 months trying to find a way to get to a point where I could dedicate a measly single week to be able to start properly looking into it. And that's a critical Rufus issue as far as I'm concerned.

So, while, I appreciate that you would like nothing more than for me to have some "time on the side" to start new projects (coz I sure would like that too!!) such as a Linux or Mac port, the reality is very different. I already have a list long like the arm of stuff I'd like to do, provided I could find and justify the time and as such, a project such as a Linux port of Rufus is something that I'd need to plan years in advance, just like the UI redesign, because, after decades of being a software developer, I can tell from experience that this project is not a simple as a matter of being able to allocate a few weeks to work on it on the side.

## 4
Source: https://github.com/pbatard/rufus/issues/1989

I think that you are misreading what I was trying to say. What I mean is that Rufus does much more than create Windows installation media. It also can create Linux bootable media (which you may think any dd like utility should be able to do, but Rufus makes sure to also do so in alternates modes besides dd), create DOS bootable media, compute MD5/SHA of ISOs, save a USB media to virtual disk, perform a bad blocks check and so on. So, if there was an application that uses the name "Rufus" for Linux or macOS, and it was only for creating Windows bootable media, I'd see it as deceptive software, since it would be missing all of the other features that Rufus does provide. So what I wanted to point out when I talked about Linux is that Rufus does much more than create Windows bootable media, and that, for me to be happy with having a macOS software use the "Rufus" name, I'd expect that software to also provide the capability to create Linux bootable media and much of the other features that the Windows version of Rufus does provide.

## 5
Source: https://github.com/pbatard/rufus/issues/2126

I'm not going to work on this. At all. So if you want to try to port Rufus to Linux, you can go ahead, but don't expect this to be a collaborative work, on account that, for the reasons I have listed in the FAQ, I don't believe that the people who want to port Rufus to Linux have a realistic idea of the work it will actually entail. in short, unless you are planning to spend months rewriting system features that are provided by default on Windows, the best you're gonna get is a utility that is missing a lot of what makes Rufus "Rufus", and that, because of this, I will kindly ask you not to call Rufus, so as not to deceive people who will be expecting things like Windows To Go support or Windows 11 hardware requirements removal...


## 6
Source: https://github.com/pbatard/rufus/issues/2126

The project is Open Source. You can create any derivative software you want (as long as you respect the licensing terms of the GPLv3). Just don't count on much help from me, especially as past experience has shown that people who are eager to port Rufus to Linux or other OSes soon come to realise, when they actually try to get to it, that it's a lot more than they can chew, especially if they are unfamiliar with pure C development and Windows APIs (in short it's not just a UI slapped on top of easily duplicatable OS calls. Instead, it's pretty much the opposite, with the UI being by far the easiest thing to port, because, unlike the rest, you are expected to find equivalent on whatever OS you are using).

In short, I just don't have the time to invest with people (there have been a few in the past) who say that they want to port Rufus to this or that OS, but seem to have failed to grasp the amount of work it'd take them, and therefore are bound to abandon the project altogether. As a matter of fact, the only people that I deem likely to succeed in porting Rufus to another OS are the ones who won't need any external help (or approval) in the first place and can simply sort what they need by reading and understanding the current source. Because if they do just that, I suspect that they will both have the competence required for the task and be tenacious (or foolish) enough to persevere with what they set to accomplish...

## 7 (a)
Source: https://www.reddit.com/r/linux4noobs/comments/abk8bw/comment/ed1ojec/

[PART 1]

Rufus developer here. Glad you asked, because a lot of people seem to think an utility like Rufus doesn't do much ("Why use Rufus when you can just use diskpart?"), and fail to realize that there is usually a lot more happening behind the scenes because of all the many quirks that are inherent to what can mostly be described as trying to fit a round peg (an ISO image) into a smaller square hole (a USB drive).

So, what does Rufus do. Well, that varies a lot depending on the type of source image you have and type of computer you are trying to boot.

  - If the source is a DD (pure disk image) or ISOHybrid image (mixed ISO and disk image), then this is the simplest case: Rufus does write it, bit for bit, without any conversion, onto the USB drive... except (quirk #1) it also first needs makes sure that there doesn't exist another process that is currently trying to access the drive in write mode, since, to reliably write to the drive, you really don't want to leave the door open for something else to also have kept some write access opened, as there is no telling how they might arbitrarily change the data you just wrote behind your back, and screw up the boot. Also, you may have to work around some Windows own quirks (quirk #2, mostly seen with Windows 10), where Windows will prevent you to write whatever you want unless you first cleared the drive properly (and by properly, Microsoft means using one of the 3 methods that are supposed to clear the partition tables and whatnot, but that are temperamental enough so that only one tends to work as expected). Now, once you managed to clear the drive, write the data, and made sure that nothing should have been able to modify it behind your back, then you "should" be able to rely on the makers of the image to have sorted the USB boot, so your job is done (or at least, if it doesn't work, it's not your issue).

However, not all ISOs are ISOHybrids. Especially the Windows ISOs aren't, so the method above, which we call "DD Mode", cannot be applied all the time. Besides, DD writing presents major drawbacks for Windows users in that the image may be written using a file system that Windows does not support, in which case many people are going to be confused as to why they are no longer able to see or access the content of their USB in File Explorer, or, in case the image contains an EFI System Partition, why they suddenly only see a super small FAT32 partition with next to no content, from what used to be a large USB... And even if the image does use a file system / partition mapping (remember, Windows version prior to Win10 1703 could not mount more than one partition from a drive with the "removable" attribute, which most USB Flash Drives will have) that lets users access the data from Windows, by writing in DD Mode, you are only ever going to be able to use your drive up to the maximum size of the original image. In other words, this means that if the people who created a DD/ISOHybrid image used a 4GB image, then, if it gets copied on a 32GB drive, there's going to be 28GB of data that you can't use at all, until you repartition and reformat your drive, which of course isn't ideal... And I'm not even going to comment on how ISOHybrid is a major hack in the first place, by trying to combine two completely different file systems do stuff they were never designed to do, with all the problems that can ensue (which is why it's very unlikely you're ever going to see ISOHybrid versions of Windows ISOs. But then again, who knows...). For the record, this is the reason you can't use Etcher to write a Windows ISO to an USB drive because Etcher can only cope with DD or ISOHybrid images. Despite what many people seem to believe, because it has become the norm to use it on recent popular Linux distros, ISOHybrid is the exception rather than the norm, so if you only support "DD Mode", you're going to be stuck at some stage...

So, what do you do when you don't have a DD or ISOHybrid image. Well, that is where things start to get a lot more "interesting".

  - A lot of people seem to think that, if that ISO is UEFI compatible, then it's about as easy as writing a DD image, in that you simply need to copy the content of the ISO onto a FAT32 formatted partition, and you're good to go... Except you may have a file on that ISO that is larger than 4 GB (For instance ALL of the recent retail versions of the Windows 10 1809 are like that), in which case you can't use FAT32 (file system design limits the maximum size of a single file to 4GB or less), and you need to apply some workaround to boot from NTFS. So Rufus does detect that and applies the relevant quirk appropriately (quirk #3). Also, and it turns out that some Linux distros, such as Mandriva (which I'm calling out, because I have opened a bug with them on this for more than 6 months now, and despite repeated requests for updates, they have yet to acknowledge it), have drunk a bit too much of the ISOHybrid Kool-aid, and decided to remove the FAT32 file system driver from their custom GRUB bootloader, which of course wrecks havoc for the boot process of unsuspecting users... And that's not even mentioning some of the Debian derivatives' ISOHybrids that don't bother having the UEFI bootloaders present on the ISO file system, so that they will get copied automatically if you duplicate the ISO content, but instead cram them into a virtual efi.img FAT image. So (quirk #4), Rufus must also extract the efi.img content so that, if you use ISO Mode and not DD Mode, the resulting drive should still boot. Oh, and then there's Windows 7, which is UEFI compatible (at least for the x64 version), but only after you rename/copy the relevant EFI loader in the right place (quirk #5). Still, converting an UEFI bootable ISO to UEFI bootable USB is actually pretty straight forward (provided the people who created the ISO made sure their content could be booted in Hard Disk mode from a FAT32 or NTFS file system)...


## 7 (b)

Source: https://www.reddit.com/r/linux4noobs/comments/abk8bw/comment/ed1ok7o/



[PART 2]

  - Things however get A LOT more complicated when you need to convert your ISO not for UEFI USB boot, but for BIOS USB boot, because that's where you get submerged by the quirks. And there are still a lot of BIOS based machines out there. Your first problem being that, when you boot an ISO on a BIOS computer, you will be using a completely different method than when you boot an USB Flash Drive. In the first case, you don't need to care about bootable attributes, partitions, boot records (such as the Master Boot Record, or "MBR" which you might have heard of) and whatnot. In the second, you very much do. So, when you are converting a BIOS bootable ISO image to a BIOS bootable USB image, there's A LOT that needs to happen behind the scenes. First of all, because everybody can create their own custom way of booting an ISO from a CD/DVD drive, an application like Rufus must be able to provide the USB/HDD equivalent of whatever binary was used by the ISO. Thankfully, in the case of Linux distros, there only seems to exist 2 types of BIOS bootloaders being used: Syslinux or GRUB. So, what Rufus does is, detect whether the ISO version of GRUB or Syslinux is being used by the image and then write a HDD version of the same bootloader (because, once again, the ISO version of GRUB of Syslinux is absolutely hopeless at booting a USB or HDD, so you can't even patch the existing binary to do so). So that's why you may have to download some files from a remote server during the conversion process. And it gets even more "interesting" because (quirk #6) the Syslinux people have somehow managed to make their versions of Syslinux incompatible with one another, especially when it comes to modules (which thankfully, though not always -- but this is a quirk that I'm not going to count, you can reuse from ISO to USB/HDD). For instance, you can't use modules built for Syslinux 5.01 with Syslinux 5.02... or even between some pre-releases of the same version!), so you need to detect and handle that, rather than blindly copy whatever Syslinux binary you may have tried to include in Rufus. Oh, and some distros (Manjaro... why is it always them?) may decide to use custom build options for GRUB so (quirk #7) you need to sort that out as well. Oh and then there's the whole issue of GRUB or Syslinux config files that may be looking for a media installation partition with a specific label... that can't be converted to a FAT32 one, because FAT32 volumes are limited to 11 uppercase characters, so (quirk #8) you may want to fix that as well. Should I mention that that last quirk also applies to UEFI? But that's still just for GRUB or Syslinux and as I said, everybody can write their custom ISO bootloader, for which Rufus will need to provide a USB equivalent, so having a conversion process for GRUB or Syslinux will only get you so far. And that is why we also have bootloaders for ReactOS or KolibriOS. Apart from that, we also had to write out own MBR (quirk #9), to emulate the Windows BIOS ISO bootloader, that asks the user to press for a key, so that the multi-reboot process of Windows installation in BIOS mode could be conducted unattended, as it can be from optical drive.

Oh, and possibly, you may want to create Windows To Go drives (I think there's at least 3 more quirks on that, even if we mostly rely on internal Windows utilities and APIs), or see your drive labelled with the right name (more quirks) or get MS-DOS (more quirks, since we can't redistribute MS-DOS, only Microsoft can) or FreeDOS installed, with a locale & keyboard that matches the one from the system you created the drive with (even more quirks)...

So, to answer your question, what Rufus is actually doing is a very straightforward bootable ISO → bootable USB conversion... while also trying not to bring too much attention to all the corner cases that need to be accounted for and that require extensive quirks to be applied, in order to make people wonder if there's really that much happening behind the scenes... ;)


## 8
Source: Rufus FAQ

I certainly wish I could, because it sounds like a nice challenge, but I just don't have the time for that. Also, Rufus was designed to work very closely with the Windows APIs, and while the application may appear deceptively simple, what really happens behind the scenes is anything but.

So porting Rufus to another OS is actually a lot more effort than people seem to imagine. For instance, I currently estimate that getting a Linux version of Rufus, that would offer at least 75% of the capabilities of the Windows version (which, as far as I'm concerned, isn't even close to something I would be satisfied releasing to the public, as it would still be missing too many features), is at least a 4-months full time work endeavour. Realistically then, I can't see myself dropping everything else, and spending 8-10 hours a day for 4 or more months, just to get a basic Linux version of Rufus that would still be missing features that I consider essential (such as the ability to create Windows To Go images for instance)...

Besides, most of these platforms already have the tools needed to help you achieve part of what Rufus does (though perhaps not in as convenient a package). As a matter of fact, Rufus relies on tools that were originally designed and run on other platforms than Windows such as Syslinux, ms-sys or the bad blocks check feature from e2fsprogs, so at least these capabilities can be obtained on other platforms.

Then again, Rufus is Free Software, so if anybody wants to try to port it to another platform, they are very welcome to do so! 